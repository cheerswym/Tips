syntax = "proto2";

package qcraft;
option go_package = "qcraft-proto.ai/onboard/lite/proto/module_config";

import "onboard/lite/proto/lite_common.proto";

message LiteModuleConfig {
  // The class name of module, extended from LiteModule.
  optional string module_class_name = 1;
  // The enum type of module name.
  optional LiteModuleName module_name = 2;

  message PubSubMessage {
    // The field name listed in LiteMsg, used to identify which proto in
    // LiteMsg.
    optional string field_name = 1;

    // Empty means use lite_msg_field_name as channel name, otherwise use this
    // field as new channel name.
    optional string channel = 2;

    // The domain it publishes/subcribes to.
    optional string domain = 3;

    // The minimum execution interval of the pub/sub function for the message
    // in seconds. Positive `interval` will enable rate checking for
    // over-execution.
    optional double min_interval = 4;

    // The maximum execution interval of the pub/sub function for the message
    // in seconds. Positive `interval` will enable rate checking for
    // under-execution.
    optional double max_interval = 5;

    // Tag is channel's sensor id
    optional string sensor_id = 6;

    // The minimum frequency at which the channel is sent, less than this
    // frequency is abnormal.
    optional int64 min_frequency = 7;

    // The maximum frequency that the channel is sent, if it is greater than
    // this frequency, it is abnormal.
    optional int64 max_frequency = 8;

    // Window size for calculating frequency.
    optional int64 frame_window_size = 9;

    // If a msg is defined as critical, the module is truly READY only if the
    // msg is sent out once.
    optional bool critical = 10 [default = false];

    // If it's true to an input decl, means to accept msg from remote nodes
    optional bool allow_xnode_input = 11 [default = false];
  }

  repeated PubSubMessage inputs = 4;

  repeated PubSubMessage outputs = 5;
  // TODO(kun): Support more configurations here, like rate checker.

  // Only used for simulation
  repeated ModuleStateChannelPair default_state_channel_pairs = 6;

  // Module startup and exit priority
  optional int32 module_startup_exit_priority = 7;

  // channel checker config
  repeated PubSubMessage checkers = 8;

  // CPU cores bound to the module.
  repeated int32 cpu_core_to_bind = 9 [deprecated = true];

  // Maximum CPU usage of the module.
  optional int64 max_cpu_usage = 10;

  // Maximum memory usage of the module.
  optional int64 max_memory_usage_kb = 11;

  // heartbeat check config, unit:us
  message HeartbeatItem {
    optional int64 kickout_deadline = 1 [default = 500000];
    optional int64 terminate_deadline = 2 [default = 3000000];
  }

  // Heartbeat check config.
  optional HeartbeatItem heartbeat_config = 12;

  // How many times will the module restart after crash.
  optional int32 module_restart_times = 13;

  // Memory check config, unit:MB
  message MemoryItem {
    optional int64 kickout_deadline = 1 [default = 2048];
    optional int64 terminate_deadline = 2 [default = 6000];
  }

  // Memory check config.
  optional MemoryItem memory_config = 14 [deprecated = true];

  // Shared memory check config.
  optional MemoryItem shared_memory_config = 15 [deprecated = true];

  // Cpu usage check config, unit:%
  message CpuItem {
    optional int64 kickout_deadline = 1 [default = 100];
    optional int64 terminate_deadline = 2 [default = 400];
  }

  // Shared memory check config.
  optional CpuItem cpu_config = 16 [deprecated = true];
}

message LaunchRunConfig {
  // Cpu usage check config, unit:%
  message CpuItem {
    optional int64 kickout_deadline = 1 [default = 100];
    optional int64 terminate_deadline = 2 [default = 400];
  }

  // Memory check config, unit:MB
  message MemoryItem {
    optional int64 kickout_deadline = 1 [default = 2048];
    optional int64 terminate_deadline = 2 [default = 6000];
  }

  message ModuleResourceConfig {
    optional LiteModuleName module_name = 1;
    // CPU cores bound to the module.
    repeated int32 cpu_core_to_bind = 2;

    // Shared memory check config.
    optional CpuItem cpu_config = 3;

    // Memory check config.
    optional MemoryItem memory_config = 4;

    // Shared memory check config.
    optional MemoryItem shared_memory_config = 5;
  }

  repeated string lite_module_config_filenames = 1;
  repeated ModuleResourceConfig module_resource_configs = 2;
}

message NodeConfig {
  // Used to identify which node will be the server node.
  optional string node_name = 1;

  // Used to describe where node will be run.
  optional string name_space = 2;

  // The ip address that you want to be listen or connect to.
  optional string node_ip = 3;

  // The ip port that you want to be listen or connect to.
  optional string node_port = 4;

  // Filenames saved under launch_config.
  optional string lite_launch_config_filename = 5;

  // The timeout of the connnect/transimitter/receiver function for the
  // message in microseconds.
  optional int32 timeout = 6;
}

message NodesRunConfig {
  // The scheme name of DBQ(Driven by QCraft) System, such as
  // nodes_normal_7, nodes_standard_12, nodes_upgrade_15
  optional string nodes_scheme_name = 1;

  repeated NodeConfig nodes = 2;
}

enum ExceptionLevel {
  NOT_EXCEPTION = 0;
  SMALL_EXCEPTION = 1;
  MEDIUM_EXCEPTION = 2;
  LARGE_EXCEPTION = 3;
  SERIOUS_EXCEPTION = 4;
}