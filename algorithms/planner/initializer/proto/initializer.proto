
syntax = "proto2";
package qcraft.planner;
option go_package = "qcraft-proto.ai/onboard/planner/initializer/proto/initializer";

import "onboard/proto/trajectory_point.proto";

message MotionStateProto {
  optional double x = 1;
  optional double y = 2;
  optional double h = 3;  // heading.
  optional double k = 4;  // curvature.
  optional double t = 5;  // time.
  optional double v = 6;  // velocity.
  optional double a = 7;  // acceleration.
}

message MotionGraphProto {
  message MotionNode {
    optional int32 index = 1;
    optional MotionStateProto state = 2;
  }
  message MotionEdge {
    optional int32 start_node_index = 1;
    optional int32 end_node_index = 2;
    optional int32 prev_edge_index = 3;
  }

  repeated MotionNode nodes = 1;
  repeated MotionEdge edges = 2;
}

message MotionSearchResultProto {
  repeated string cost_names = 2;

  optional MotionGraphProto motion_graph = 5;
  optional int32 best_last_edge_index = 6;
  repeated int32 search_queue = 7;  // Edge index in motion graph.

  message MotionEdgeCost {
    repeated double costs = 1;  // Same size with cost_names
    optional double cum_cost = 2;
  }

  repeated MotionEdgeCost edge_costs =
      8;  // Same size with motion_graph's edges

  reserved 1, 3, 4;
}

message DpMotionSearchResultProto {
  repeated string cost_names = 2;  // feature costs

  message TrajectoryCost {
    repeated double costs = 1;  // Same size with cost_names
    optional double total_cost = 3;
    optional int32 last_edge_idx = 4;
    reserved 2;
  }

  message TrajectoryWithLeadingObject {
    optional InitializerResultTrajectoryProto trajectory = 1;
    repeated string leading_obj_id = 2;
    optional TrajectoryCost cost = 3;
  }

  repeated InitializerResultTrajectoryProto trajectory = 1;
  repeated TrajectoryCost traj_costs =
      3;  // Same size with considered_trajectories

  optional double min_cost = 4;
  reserved 5;
  repeated TrajectoryWithLeadingObject traj_with_lead_obj = 6;
}

message ExpertEvaluationProto {
  repeated string cost_names = 1;  // feature costs' name
  repeated double costs = 2;       // unweighted, same size with cost_names
  optional double total_cost =
      3;  // with weighted defined by onboard initializer's config
  optional InitializerResultTrajectoryProto trajectory = 4;
  repeated double weights = 5;
}

message SampledDpMotionEvaluationProto {
  repeated string cost_names = 1;  // feature costs' name

  message TrajectoryCost {
    repeated double costs = 1;  // unweighted, same size with cost_names
    optional double total_cost =
        2;  // with weighted defined by onboard initializer's config
  }

  repeated InitializerResultTrajectoryProto trajectory = 2;
  repeated TrajectoryCost traj_costs =
      3;  // Same size with considered_trajectories with weighted defined by
          // onboard initializer's config

  optional double min_cost = 4;
  repeated double weights = 5;
}

message GeometryGraphDebugProto {
  message ConnectionProcess {
    message GraphNode {
      optional int32 layer_index = 1;
      optional int32 node_on_layer_index = 2;
      optional int32 station_index = 3;
    }

    enum ConnectionResult {
      SUCCESS = 1;
      OMIT_TOO_SHORT = 2;
      OMIT_LATERAL_OFFSET = 3;
      OMIT_NOT_CONVERGE_TO_CENTER = 4;
      FAIL_NO_POLY = 5;
      COLLIDE_TRUNCATE = 6;
      COLLIDE_NO_EDGE = 7;
      FAIL_CURB_COLLISION = 8;
      FAIL_INVALID_CURVATURE = 9;
      NOT_SET = 10;
    }

    message CollisionInfo {
      // Size of collision_accum_s and collide_obj_id should be the same.
      repeated double collision_accum_s = 1;
      repeated string collide_obj_id = 2;
    }

    // Show the whole process of geometry graph connection
    optional GraphNode start = 1;
    optional GraphNode end = 2;
    optional ConnectionResult connection_result = 3;
    optional CollisionInfo collision_info = 4;
  }

  message ResampleResult {
    enum ResampleReason {
      RESAMPLED = 1;
      NR_ZERO_REACHABLE = 2;
      NR_ALL_REACHABLE = 3;
      NR_INVALID_RANGE = 4;
      NR_LATERAL_RESOLUTION = 5;
      NOT_INITIALIZED = 6;
    }
    optional int32 layer_idx = 1;
    optional ResampleReason resample_reason = 2;
  }

  repeated ConnectionProcess connection_process = 1;
  repeated ResampleResult resample_result = 2;

  // Give collisiont traj id and how many edges have collided with this object
  // (static).
  message StaticCollision {
    optional string collision_traj_id = 1;
    optional int32 number = 2;
  }
  repeated StaticCollision static_collision = 3;
}

message GeometryGraphProto {
  message GeometryState {
    optional double x = 1;
    optional double y = 2;
    optional double h = 3;
    optional double k = 4;
  }
  message GeometryNode {
    optional double x = 1;
    optional double y = 2;
    optional uint32 station_index = 3;
    optional uint32 node_index = 4;
    optional bool active = 5;
    optional bool resampled = 6;
  }
  message GeometryEdge {
    optional uint32 start_node_index = 1;
    optional uint32 end_node_index = 2;
    repeated GeometryState states = 3;
    optional bool active = 4;
    optional bool truncated = 5;
  }
  message OutgoingEdges {
    repeated int32 outgoing_edge_index = 1;
  }
  enum EndReason {
    END_NONE = 0;
    END_REACH_MAX_SAMPLING_DIS = 1;
    END_STOP_LINE = 2;
    END_STATIC_LEADING_OBJ = 3;
    END_STATIC_OBJ = 4;
  }
  message EndInfo {
    optional EndReason end_reason = 1;
    optional string object_id = 2;
    optional double end_route_s = 3;
    optional double end_accumulated_s = 4;
  }

  message ReferenceLine {
    message EdgeCost {
      optional int32 edge_idx = 1;
      repeated double feature_costs = 2;
      optional double total_cost = 3;
    }
    repeated int32 node_idxes = 1;
    repeated int32 edge_idxes = 2;
    repeated PathPoint ref_line_points = 3;
    repeated string cost_names = 4;
    optional double total_cost = 5;
    repeated double feature_costs = 6;
    repeated EdgeCost edge_costs = 7;
  }

  repeated GeometryNode nodes = 1;
  repeated GeometryEdge edges = 2;
  repeated OutgoingEdges outgoing_edges =
      3;  // Should be the same size with edges.
  optional EndInfo end_info = 4;
  optional ReferenceLine reference_line = 5;
}

message InitializerSmoothedDrivePassageProto {
  message Point {
    optional double x = 1;
    optional double y = 2;
    optional double z = 3;
  }

  repeated Point smoothed_drive_passage_points = 1;
  repeated Point drive_passage_points = 2;
}

message InitializerResultTrajectoryProto {
  repeated ApolloTrajectoryPointProto trajectory_points = 1;
}

message InitializerSelectorDebugProto {
  // Store evaluation results when initializer considers multiple trajectories.
  message TrajectoryEvalInfo {
    repeated string leading_object = 1;
    optional double leading_object_cost = 2;
    optional double total_cost = 3;
    optional double final_lon_progress_cost = 4;
    optional double final_eval_cost = 5;
    optional string object_causing_min_lon = 6;
    optional double min_lon_dist = 7;
    optional bool ttc_check = 8;
    optional bool dead_zone_check = 9;
  }
  optional bool single_choice_received = 1;
  repeated TrajectoryEvalInfo traj_eval = 2;
}

message InitializerDebugProto {
  optional GeometryGraphProto geom_graph = 1;
  optional MotionSearchResultProto motion_search_result = 2;
  optional InitializerResultTrajectoryProto resampled_initializer_trajectory =
      3;
  optional DpMotionSearchResultProto dp_motion_search_result = 4;
  optional InitializerSmoothedDrivePassageProto smoothed_drive_passage = 5;
  optional GeometryGraphDebugProto geometry_graph_debug = 6;
  reserved 7;
  optional InitializerSelectorDebugProto selector_debug_proto = 8;
  // The initializer's trajectories start timestamp in seconds.
  optional double trajectory_start_timestamp = 9;

  // For data dumping
  optional ExpertEvaluationProto expert_evaluation = 100;
  optional SampledDpMotionEvaluationProto candidates_evaluation = 101;
}

enum InitializerSamplePatternConfig {
  ISC_NONE = 0;
  ISC_HIGH_SPEED = 1;    // > 14.0 m/s.
  ISC_MEDIUM_SPEED = 2;  // 8.0 ~ 14.0 m/s.
  ISC_LOW_SPEED = 3;     // < 8.0 m/s.
}

message InitializerStateProto {
  optional InitializerSamplePatternConfig sample_pattern_config = 1;
  optional GeometryGraphProto.EndInfo end_info = 2;
  optional InitializerSearchConfig search_config = 3;
  optional double s_from_start = 4;
  optional ApolloTrajectoryPointProto prev_start_point = 5;
}

message InitializerSearchConfig {
  message LeadingObjectConfig {
    repeated string front = 1;
    repeated string rear = 2;
  }
  optional bool is_lane_change = 1;
  optional LeadingObjectConfig leading_object_config = 2;
}