#include "onboard/planner/speed/ignore_decider.h"

#include <algorithm>
#include <string>

#include "onboard/lite/logging.h"
#include "onboard/math/vec.h"
#include "onboard/planner/util/path_util.h"

namespace qcraft {
namespace planner {
namespace {

constexpr double kEpsilon = 0.01;

bool IgnoreHitAvEmergencyStopTrajectoryStBoundary(
    const std::vector<StPoint>& emergency_stop_points,
    const StBoundary& st_boundary) {
  // Don't ignore st-boundaries that would hit path in a short time.
  constexpr double kShortTime = 1.0;  // s.
  if (st_boundary.min_t() < kShortTime) return false;

  constexpr double kCheckCollisionSBuffer = 0.2;  // m.
  bool st_boundary_passed = false;
  const auto start_iter = std::lower_bound(
      emergency_stop_points.begin(), emergency_stop_points.end(),
      st_boundary.min_t(),
      [](const StPoint& point, double t) { return point.t() < t; });
  for (auto it = start_iter; it < emergency_stop_points.end(); ++it) {
    const auto& st_point = *it;
    const double curr_s = st_point.s();
    const double t = st_point.t();
    const auto s_range = st_boundary.GetBoundarySRange(t);
    if (!s_range.has_value()) {
      if (!st_boundary_passed) {
        continue;
      } else {
        return false;
      }
    }
    st_boundary_passed = true;
    if (curr_s > s_range->second - kCheckCollisionSBuffer) {
      VLOG(2) << "St-boundary " << st_boundary.id()
              << " is ignored because AV would hit it at t = " << t
              << " s = " << curr_s << " by emergency stop.";
      return true;
    }
  }
  return false;
}

inline bool IgnoreHitAvCurrentPositionStBoundary(
    const StBoundary& st_boundary) {
  return st_boundary.bottom_left_point().s() <= kEpsilon &&
         st_boundary.bottom_left_point().t() >= 0.0;
}

bool IgnoreBackCutInStBoundary(
    const SpacetimeTrajectoryManager& st_traj_mgr,
    const VehicleGeometryParamsProto& vehicle_geometry_params,
    const PathPointSemantic& current_path_semantic,
    const PathPoint& current_path_point, const StBoundary& st_boundary) {
  if (!st_boundary.overlap_meta().has_value()) return false;
  if (st_boundary.overlap_meta()->source() !=
      StOverlapMetaProto::OBJECT_CUTIN) {
    return false;
  }
  const auto current_lane_semantic = current_path_semantic.lane_semantic;
  if (current_lane_semantic == LaneSemantic::NONE ||
      current_lane_semantic == LaneSemantic::INTERSECTION_UTURN) {
    return false;
  }
  QCHECK(st_boundary.traj_id().has_value());
  const auto& traj_id = *st_boundary.traj_id();
  const auto* traj = QCHECK_NOTNULL(st_traj_mgr.FindTrajectoryById(traj_id));

  // Even if st_boundary is generated by a modified prediction, we can safely
  // estimate its current contour from spacetime trajectory manager.
  const auto& obj_contour = traj->contour();
  const auto current_path_dir =
      Vec2d::FastUnitFromAngle(current_path_point.theta());
  const auto& obj_most_front_point =
      obj_contour.points()[obj_contour.ExtremePoint(current_path_dir)];
  const bool behind_current_path_point =
      (obj_most_front_point - ToVec2d(current_path_point))
          .Dot(current_path_dir) <
      -vehicle_geometry_params.back_edge_to_center();

  if (current_lane_semantic == LaneSemantic::ROAD ||
      current_lane_semantic == LaneSemantic::INTERSECTION_STRAIGHT) {
    // If AV is on road or going straight at intersection, check if object
    // current contour is behind current path point.
    return behind_current_path_point;
  } else if (current_lane_semantic == LaneSemantic::INTERSECTION_LEFT_TURN ||
             current_lane_semantic == LaneSemantic::INTERSECTION_RIGHT_TURN) {
    // If AV is turning left/right at intersection, check if object current
    // contour is behind current path point and on the right/left of AV
    // left/right edge.
    if (!behind_current_path_point) return false;
    const auto check_dir =
        current_lane_semantic == LaneSemantic::INTERSECTION_LEFT_TURN
            ? current_path_dir.Perp()
            : -current_path_dir.Perp();
    const auto& obj_most_point =
        obj_contour.points()[obj_contour.ExtremePoint(check_dir)];
    return (obj_most_point - ToVec2d(current_path_point)).Dot(check_dir) <
           0.5 * vehicle_geometry_params.width();
  }

  QLOG(FATAL) << "Should not be here.";
  return false;
}

}  // namespace

void MakeIgnoreDecisionForStBoundary(const IgnoreDeciderInput& input,
                                     StBoundaryWithDecision* st_boundary_wd) {
  QCHECK_NOTNULL(st_boundary_wd);
  QCHECK_NOTNULL(input.emergency_stop_points);
  QCHECK_NOTNULL(input.path);
  QCHECK_NOTNULL(input.path_semantics);
  QCHECK_NOTNULL(input.st_traj_mgr);
  QCHECK_NOTNULL(input.vehicle_geometry_params);

  if (st_boundary_wd->decision_type() != StBoundaryProto::UNKNOWN) {
    return;
  }
  const auto& st_boundary = *st_boundary_wd->raw_st_boundary();
  if (st_boundary.source_type() != StBoundary::SourceType::ST_OBJECT) {
    return;
  }
  if (st_boundary.is_stationary()) return;

  const auto make_ignore_decision = [](const std::string& decision_info,
                                       StBoundaryWithDecision* st_boundary_wd) {
    st_boundary_wd->set_decision_type(StBoundaryProto::IGNORE);
    st_boundary_wd->set_decision_reason(StBoundaryProto::IGNORE_DECIDER);
    st_boundary_wd->set_decision_info(decision_info);
  };

  // 1. Ignore st-boundaries hit AV emergency stop trajectory.
  if (IgnoreHitAvEmergencyStopTrajectoryStBoundary(*input.emergency_stop_points,
                                                   st_boundary)) {
    make_ignore_decision("ignore hit AV emergency stop trajectory",
                         st_boundary_wd);
    return;
  }

  // 2. Ignore st-boundaries hit AV current position.
  if (IgnoreHitAvCurrentPositionStBoundary(st_boundary)) {
    make_ignore_decision("ignore hit current AV position", st_boundary_wd);
    return;
  }

  // 3. Ignore back cut-in st-boundaries.
  if (!input.path_semantics->empty() &&
      IgnoreBackCutInStBoundary(
          *input.st_traj_mgr, *input.vehicle_geometry_params,
          input.path_semantics->front(), input.path->front(), st_boundary)) {
    make_ignore_decision("ignore back cutin", st_boundary_wd);
    return;
  }
}

}  // namespace planner
}  // namespace qcraft
