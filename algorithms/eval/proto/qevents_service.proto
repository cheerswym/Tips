syntax = "proto2";

import "onboard/eval/proto/qevent.proto";

package qcraft;
option go_package = "qcraft-proto.ai/offboard/eval/proto/qevents_service";

message InsertQEventsRequest {
  repeated QEventProto qevents = 1;
}

message InsertQEventsResponse {}

message ListEventsRequest {
  optional string source_id = 1;

  // filter expression. it is a more generic filter setting, the source_id will
  // be ignored when filter setted
  optional string filter = 2;

  // pagenation
  optional int32 page_size = 3;
}

message ListEventsResponse {
  repeated QEventProto events = 1;
}

message DiffEventsRequest {
  repeated string filters = 1;
  optional QEventGrouper grouper = 2;
  // pagenation
  optional int32 page_size = 3;
}

message DiffEventsResponse {
  // example:
  // 4 event groups and 2 selections
  // event groups:  | 0 | 1   | 2 | 3 |
  // selections(0): | A | B D | E |   |
  // selections(1): |   | B   | E | F |
  // #selections == #request.run_ids must hold.
  message EventsGroup {
    message Events {
      repeated QEventProto events = 1;
    }
    repeated Events selections = 1;
    optional string event_name = 2;
  }
  repeated EventsGroup events_groups = 1;
}

message QEventStats {
  optional string source_id = 1;
  map<string, int32> stats = 2;
}

message InsertStatsRequest {
  optional string source_id = 1;
  optional QEventStats stats = 2;
}

message InsertStatsResponse {}

message GetStatsRequest {
  optional string source_id = 1;
}

service QEventsService {
  rpc InsertQEvents(InsertQEventsRequest) returns (InsertQEventsResponse);
  rpc ListEvents(ListEventsRequest) returns (ListEventsResponse);
  rpc DiffEvents(DiffEventsRequest) returns (DiffEventsResponse);

  rpc InsertStats(InsertStatsRequest) returns (InsertStatsResponse);
  rpc GetStats(GetStatsRequest) returns (QEventStats);
}